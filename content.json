[{"title":"【置顶】文章目录","date":"2049-12-31T16:00:00.000Z","path":"2050/01/01/【置顶】文章目录/","text":"前言感觉文章太多，翻着麻烦，于是想着搞个目录。（不要在意时间）注1：不包含未完成的文章注2：还有一些瞎搞的和奇奇怪怪的文章也不放在目录里注3：你要是真的想看这些东西——自己翻去吧~~注4：不要点MORE，这篇文章我没折叠。。。 1.经典算法系列分治算法贪心算法 2.奇(ge)怪(zhong)的算法单调队列Tarjan线段树KMP并查集最小生成树SPFA 3.C++实用技巧与STL库FIFO队列与优先队列(queue)关联式容器(map)对组(pair) 4.NOIP实用技巧打表大神的对抗对拍NOIP易错点NOIP背代码","link":"","categories":[{"name":"目录","slug":"目录","permalink":"http://yoursite.com/categories/目录/"}],"tags":[{"name":"目录","slug":"目录","permalink":"http://yoursite.com/tags/目录/"}]},{"title":"树形DP","date":"2016-10-26T12:26:25.000Z","path":"2016/10/26/树形DP/","text":"前言在树上搞DP？好高大上的DP。。。 1.思想外瑞库，康明松。 2.树形DP例题之选课【题目链接】洛谷【2014】【题目描述】在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？【输入格式】第一行有两个整数N,M用空格隔开。(1&lt;=N&lt;=300,1&lt;=M&lt;=150)接下来的N行,第I+1行包含两个整数ki和si, ki表示第I门课的直接先修课，si表示第I门课的学分。若ki=0表示没有直接先修课（1&lt;=ki&lt;=N, 1&lt;=si&lt;=20）。【输出格式】只有一行，选M门课程的最大得分。【输入样例】 7 42 20 10 42 17 17 62 2 【输出格式】 13 【程序】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;iostream&gt;#define M 500500using namespace std;int n,m;int head[M],next[M],w[M];int f[M/100][M/100];int dfs(int x)&#123; if(head[x]==0) return 0; int ans=0; for(int i=head[x];i;i=next[i]) &#123; int t=dfs(i); ans+=t+1; for (int j=ans;j&gt;=0;j--) &#123; for (int k=0;k&lt;=t;k++) &#123; if (j-k-1&gt;=0) f[x][j]=max(f[x][j],f[x][j-k-1]+f[i][k]); &#125; &#125; &#125; return ans;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); int ta,tb; for(int i=1;i&lt;=n;++i) &#123; scanf(\"%d%d\",&amp;ta,&amp;tb); next[i]=head[ta]; head[ta]=i; w[i]=tb; &#125; for(int i=0;i&lt;=n;++i) f[i][0]=w[i]; dfs(0); printf(\"%d\",f[0][m]); return 0;&#125;","link":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/categories/动态规划/"},{"name":"DFS","slug":"动态规划/DFS","permalink":"http://yoursite.com/categories/动态规划/DFS/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"最小生成树（MST）","date":"2016-10-20T11:59:47.000Z","path":"2016/10/20/最小生成树/","text":"前言删繁就简。。。就用最小生成树。。。 1.思想这里使用的是Kruskal算法。 首先，MST的用途是在一个有n个点的无向图里，选出(n-1)条变组成一个新的连通图，求最小边权值。 用并查集来维护图的连通性； 将所有边按边权值从小到大排序； 如果一条边连接的两个点不在一个并查集里，用这条边连接这两个点。 因为是按边权值升序排序的，所以可以保证每次选取的都是最小边权值的边。2.最小生成树模板题【题目链接】洛谷【3366】【题目描述】如题，给出一个无向图，求出最小生成树。（原题说如果不连通则输出orz，然而并没有输出orz的点。。。）【输入格式】第一行包含两个整数N、M，表示该图共有N个结点和M条无向边。（N&lt;=5000，M&lt;=200000）接下来M行每行包含三个整数Xi、Yi、Zi，表示有一条长度为Zi的无向边连接结点Xi、Yi【输出格式】输出包含一个数，即最小生成树的各边的长度之和。【输入样例】 4 51 2 21 3 21 4 32 3 43 4 3 【输出样例】 7 【程序】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define M 500500using namespace std;int n,m,ans;struct E&#123; int from,to,w;&#125;e[M];int tope;inline void ae(int x,int y,int z)&#123; tope++;e[tope].to=y;e[tope].from=x;e[tope].w=z;&#125;int fa[M];inline void reinit()&#123; for(int i=1;i&lt;=n;++i) &#123; fa[i]=i; &#125;&#125;int find(int x)&#123; if(x!=fa[x]) fa[x]=find(fa[x]); return fa[x];&#125;int pd(int x,int y)&#123; if(find(x)==find(y)) return 1; return 0;&#125;inline void un(int x,int y)&#123; fa[find(x)]=find(y);&#125;int cmp(E x,E y)&#123; return x.w&lt;y.w;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); int ta,tb,tc; for(int i=1;i&lt;=m;++i) &#123; scanf(\"%d%d%d\",&amp;ta,&amp;tb,&amp;tc); ae(ta,tb,tc); &#125; sort(e+1,e+tope+1,cmp); reinit(); for(int i=1;i&lt;=tope;++i) &#123; if(pd(e[i].from,e[i].to)==0) &#123; un(e[i].from,e[i].to); ans+=e[i].w; &#125; &#125; printf(\"%d\",ans); return 0;&#125;","link":"","categories":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/categories/最小生成树/"},{"name":"并查集","slug":"最小生成树/并查集","permalink":"http://yoursite.com/categories/最小生成树/并查集/"},{"name":"贪心","slug":"最小生成树/并查集/贪心","permalink":"http://yoursite.com/categories/最小生成树/并查集/贪心/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/最小生成树/"}]},{"title":"并查集","date":"2016-10-20T10:34:54.000Z","path":"2016/10/20/并查集/","text":"前言父父子子，君君臣臣。。。并查集也。。。 1.思想用一个fa[]数组储存该元素的父亲，如果两个元素的父亲是同一个元素，那么它们就在同一个并查集里。 2.并查集模板题【题目链接】洛谷【3367】【题目描述】如题，现在有一个并查集，你需要完成合并和查询操作。【输入格式】第一行包含两个整数N、M，表示共有N个元素和M个操作。接下来M行，每行包含三个整数Zi、Xi、Yi；当Zi=1时，将Xi与Yi所在的集合合并；当Zi=2时，输出Xi与Yi是否在同一集合内，是的话输出Y；否则话输出N。【输出格式】如上，对于每一个Zi=2的操作，都有一行输出，每行包含一个大写字母，为Y或者N。【输入样例】 4 72 1 21 1 22 1 21 3 42 1 41 2 32 1 4 【输出样例】 NYNY 【程序】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;iostream&gt;#define M 500500using namespace std;int n,m;int fa[M];inline void reinit()&#123; for(int i=1;i&lt;=n;++i) &#123; fa[i]=i; &#125;&#125;int find(int x)&#123; if(x!=fa[x]) fa[x]=find(fa[x]); return fa[x];&#125;int pd(int x,int y)&#123; if(find(x)==find(y)) return 1; return 0;&#125;inline void un(int x,int y)&#123; fa[find(x)]=find(y);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); reinit(); int t,ta,tb; while(m--) &#123; scanf(\"%d%d%d\",&amp;t,&amp;ta,&amp;tb); if(t==1) &#123; un(ta,tb); &#125; if(t==2) &#123; if(pd(ta,tb)) printf(\"Y\\n\"); else printf(\"N\\n\"); &#125; &#125; return 0;&#125;","link":"","categories":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/categories/并查集/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"}]},{"title":"KMP","date":"2016-10-17T13:38:09.000Z","path":"2016/10/17/KMP/","text":"前言挺好用的一种字符串匹配算法。。。就是比较难懂。。。KMP=Knuth-Morris-Pratt 1.思想在不知道KMP算法的时候，大家应该都会从头到尾搜一遍，这样时间复杂度就是O(n*m)，n是字符串长度，m是子串的长度。而KMP算法相对于暴搜的优化在于它往后跳的时候不是一个一个蹦的，有时候会一下跳好几个，这样就减少了搜索的次数。 下面讲解一下KMP的大致思想：(假设被搜的字符串为a，去匹配的字符串叫b.以图片中的两行字符串为例，第一行为a，第二行为b.) 首先比较两个字符串的头：发现并不匹配，于是往后跳一个字符，继续拿b的头与当前搜到的a的位置的字符比较：一直到下图这种情况，发现能够匹配，那么就两个字符串同时往后扫：当我们扫到b的D时，发现a的这个位置并不能匹配：如果没有KMP，下一步就要让a再往后挪一个字符继续搜了： 但是！我们有KMP啊，下面就是见证奇迹的时刻：是不是很奇怪为什么要这样跳？这里我们引入一个叫做“部分匹配值$^{[1]}$”的东东：通常我们用一个next数组来储存它，往后跳的时候就把当前a上的指针加上当前已匹配的位数再减去失配时最后一个匹配的字符的部分匹配值 跳的位数 = 当前已匹配的位数 - 失配时最后一个匹配的字符的部分匹配值 6-2=4，所以就往后跳了4位：然后就继续按照这个规则跳啊跳啊：不匹配，继续跳成功近在眼前然后就完成了 [1]：“部分匹配值”表的制作过程：（来自naivekun的博客，实在不想自己写了。。。）1.首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。2.“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例: － “A”的前缀和后缀都为空集，共有元素的长度为0；－ “AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；－ “ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；－ “ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；－ “ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；－ “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；－ “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 3.“部分匹配”的实质是：有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 2.KMP模板题【题目链接】洛谷【3375】【题目描述】如题，给出两个字符串s1和s2，其中s2为s1的子串，求出s2在s1中所有出现的位置。为了减少骗分的情况，接下来还要输出子串的前缀数组next。如果你不知道这是什么意思也不要问，去百度搜[kmp算法]学习一下就知道了。【输入格式】第一行为一个字符串，即为s1（仅包含大写字母）第二行为一个字符串，即为s2（仅包含大写字母）【输出格式】若干行，每行包含一个整数，表示s2在s1中出现的位置接下来1行，包括length(s2)个整数，表示前缀数组next[i]的值。【输入样例】 ABABABCABA 【输出样例】 130 0 1 【程序】1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define M 5000000using namespace std;int la,lb;char a[M],b[M];int next[M];inline void getnext()&#123; next[0]=-1; for(int i=2,j=0;i&lt;=lb;++i,++j) &#123; while(j!=-1&amp;&amp;b[i]!=b[j+1]) j=next[j]; next[i]=j+1; &#125; &#125;inline void kmp()&#123; for(int i=1,j=0;i&lt;=la;++i,++j) &#123; while(j!=-1&amp;&amp;a[i]!=b[j+1]) j=next[j]; if(j==lb-1) printf(\"%d\\n\",i-j); &#125;&#125;int main()&#123; scanf(\"%s\",a+1); scanf(\"%s\",b+1); la=strlen(a+1); lb=strlen(b+1); getnext(); kmp(); for(int i=1;i&lt;=lb;++i) printf(\"%d \",next[i]); return 0;&#125;","link":"","categories":[{"name":"KMP","slug":"KMP","permalink":"http://yoursite.com/categories/KMP/"},{"name":"字符串","slug":"KMP/字符串","permalink":"http://yoursite.com/categories/KMP/字符串/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://yoursite.com/tags/KMP/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}]},{"title":"NOIP背代码","date":"2016-10-16T13:33:39.000Z","path":"2016/10/16/NOIP背代码/","text":"前言这些代码实在没空去仔细理解了，就背一下吧。写的有相关博客的以链接形式存在。 快速幂1234567int power(int a,int b,int P)&#123; int re=1; for(;b;b&gt;&gt;=1,a=a*a%P) if(b&amp;1) re=re*a%P; return re;&#125; 最短路SPFA123456789101112131415161718memset(ds,0x7f,sizeof(ds));//不用memset，for一遍ds[S]=0; vis[S]=1; q.push(S);while(!q.empty())&#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=0;i&lt;to[x].size();i++) &#123; int y=to[x][i],c=cost[x][i]; if(ds[y]&gt;ds[x]+c) &#123; ds[y]=ds[x]+c; if(!vis[y]) &#123; vis[y]=1; q.push(y); &#125; &#125; &#125;&#125; Dijkstra12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;climits&gt;#define M 1000000using namespace std;struct Edge&#123; int to,next,w;&#125;e[M];int head[M],tope;inline void ae(int x,int y,int z)&#123; tope++;e[tope].next=head[x];e[tope].to=y;e[tope].w=z;head[x]=tope;&#125;struct Node&#123; int x,d; inline bool operator&lt;(const Node &amp;a) const &#123; return d&gt;a.d; &#125;&#125;;inline Node make_node(int x,int y)&#123; Node a; a.x=x;a.d=y; return a;&#125;priority_queue&lt;Node&gt;pig;int n,m;int dis[M];inline void dijs_buhuipinle(int x)&#123; for(int i=1;i&lt;=n;++i) dis[i]=0x7fffffff; pig.push(make_node(x,0)); while(!pig.empty()) &#123; Node ce=pig.top();pig.pop(); if(dis[ce.x]&lt;0x7fffffff) continue; dis[ce.x]=ce.d; for(int i=head[ce.x];i;i=e[i].next) pig.push(make_node(e[i].to,ce.d+e[i].w)); &#125;&#125;int s;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s); int ta,tb,tc; for(int i=1;i&lt;=m;++i) &#123; scanf(\"%d%d%d\",&amp;ta,&amp;tb,&amp;tc); ae(ta,tb,tc); &#125; dijs_buhuipinle(s); for(int i=1;i&lt;=n;++i) printf(\"%d \",dis[i]); return 0;&#125; KMPKMP 线段树线段树 TarjanTarjan 背包问题01背包12345678910for(int i=1;i&lt;=n;i++) for(int v=0;v&lt;=m;v++) &#123; if(v-w[i]&gt;=0) f[i][v]=max(f[i-1][v],f[i-1][v-w[i]]+c[i]); else f[i][v]=f[i-1][v]; &#125; for(int i=1;i&lt;=n;i++) for(int v=m;v&gt;=w[i];v--) f[v]=max(f[v],f[v-w[i]]+c[i]); 完全背包优化：拆成$w[i]*2^k$ , $c[i]*2^k$ 的若干件（其中$w[i]*2^k$&lt;V） 12345678910for(int i=1;i&lt;=n;i++) for(int v=0;v&lt;=m;v++) &#123; if(v-w[i]&gt;=0) f[i][v]=max(f[i-1][v],f[i][v-w[i]]+c[i]); else f[i][v]=f[i-1][v]; &#125; for(int i=1;i&lt;=n;i++) for(int v=w[i];v&lt;=m;v++) f[v]=max(f[v],f[v-w[i]]+c[i]); 多重背包优化：拆成1,2,4,…, $2^(k-1)$ , $n[i]-2^k+1$ （其中k为满足$n[i]-x^k+1$&gt;0的最大整数)123456789101112131415for(int i=1;i&lt;=n;i++) for(int v=0;v&lt;=m;v++) for(int k=0;k&lt;=num[i];k++) &#123; f[i][v]=max(f[i][v],f[i-1][v]); if(v-k*w[i]&gt;=0) f[i][v]=max(f[i][v],f[i-1][v-k*w[i]]+k*c[i]); &#125; for(int i=1;i&lt;=n;i++) for(int v=m;v&gt;=0;v--) for(int k=0;k&lt;=num[i];k++) &#123; if(v-k*w[i]&lt;0) break; f[v]=max(f[v],f[v-k*w[i]]+k*c[i]); &#125; 并查集12345678910int find(int x)&#123; if(fa[x]==x) return x; else fa[x]=find(fa[x]);&#125;void un(int x,int y)&#123; fa[find(x)]=find(y);&#125; gcd1234int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125;","link":"","categories":[{"name":"noip","slug":"noip","permalink":"http://yoursite.com/categories/noip/"}],"tags":[{"name":"noip","slug":"noip","permalink":"http://yoursite.com/tags/noip/"}]},{"title":"线段树","date":"2016-10-16T11:04:01.000Z","path":"2016/10/16/线段树/","text":"前言线段树就是ST啊(Segment Tree)，其实我在玩梗233333 1.线段树思想在区间求和，区间求最值，区间修改的时候，如果遍历一遍，每次都需要O(n)的时间复杂度，加起来就是O($n^2$)的时间复杂度，很慢对吧，所以我们需要O($n*log_n$)的线段树来实现。把区间二分二分再二分，然后用树来存储与维护，就像把线段放在树里一样。 2.线段树模板建树123456789101112131415161718192021struct T&#123; int l,r,ls,rs; //l是左端点,r是右端点,ls是左儿子,rs是右儿子 int sum,ma,mark; //sum是区间和,ma是区间最值（以最大值为例）,mark是lazy标记&#125;t[M]; //M用define或者const int来定义，一般赋一个很大的值int tot=1; //计数器void build(int root,int l,int r)&#123; t[root].l=l;t[root].r=r; if(l==r) &#123; t[root].sum=a[i]; //a[i]是读入的区间内的值 t[root].ma=a[i]; return ; &#125; int mid=(l+r)/2; t[root].ls=++tot;build(t[root].ls,l,mid); t[root].rs=++tot;build(t[root].rs,mid+1,r); t[root].sum=t[t[root].ls].sum+t[t[root].rs].sum; t[root].ma=max(t[t[root].ls].ma,t[t[root].rs].ma);&#125; 区间修改12345678910111213141516void change(int x,int l,int r,int d)&#123; if(l&lt;=t[x].l&amp;&amp;r&gt;=t[x].r) &#123; t[x].mark+=d; t[x].sum+=d*(t[x].r-t[x].l+1); t[x].ma+=d; return ; &#125; push_(x); int mid=(t[x].l+t[x].r)/2; if(l&lt;=mid) change(t[x].ls,l,r,d); if(r&gt;mid) change(t[x].rs,l,r,d); t[x].sum=t[t[x].ls].sum+t[t[x].rs].sum; t[x].ma=max(t[t[x].ls].ma,t[t[x].rs].ma);&#125; 区间求和查询12345678910111213int query(int x,int l,int r)&#123; if(l&lt;=t[x].l&amp;&amp;t[x].r&lt;=r) &#123; return t[x].sum; &#125; push_(x); int ans=0; int mid=(t[x].l+t[x].r)/2; if(l&lt;=mid) ans+=query(t[x].ls,l,r); if(r&gt;mid) ans+=query(t[x].rs,l,r); return ans;&#125; 区间求最值查询（以最大值为例）123456789101112int compare(int x,int l,int r)&#123; if(t[x].l&gt;=l&amp;&amp;t[x].r&lt;=r) &#123; return t[x].ma; &#125; push_(x); int mid=(t[x].l+t[x].r)/2,maxx=0; if(l&lt;=mid) maxx=max(maxx,compare(t[x].ls,l,r)); if(r&gt;mid) maxx=max(maxx,compare(t[x].rs,l,r)); return maxx;&#125; lazy标记操作12345678void push_(int x)&#123; if(t[x].mark==0) return ; int M=t[x].mark,L=t[x].ls,r=t[x].rs; t[L].mark+=M; t[L].sum+=M*(t[L].r-t[L].l+1); t[L].ma+=M; t[R].mark+=M; t[R].sum+=M*(t[R].r-t[R].l+1); t[R].ma+=M; t[x].mark=0;&#125; 3.线段树模板题【题目链接】洛谷【3372】【题目大意】线段树区间求和&amp;&amp;单点修改【输入格式】第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。接下来M行每行包含3或4个整数，表示一个操作，具体如下：操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k；操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和。【输出格式】输出包含若干行整数，即为所有操作2的结果。【输入样例】 5 51 5 4 2 32 2 41 2 3 22 3 41 1 5 12 1 4 【输出样例】 11820 【程序】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;iostream&gt;#define M 2005000using namespace std;int n,m,q;long long a[M];struct T&#123; int l,r,ls,rs; long long sum,mark;&#125;t[M];int tot=1;void build(int x,int l,int r)&#123; t[x].l=l;t[x].r=r; if(l==r) &#123; t[x].sum=a[l]; return ; &#125; int mid=(l+r)/2; t[x].ls=++tot;build(t[x].ls,l,mid); t[x].rs=++tot;build(t[x].rs,mid+1,r); t[x].sum=t[t[x].ls].sum+t[t[x].rs].sum;&#125;void push_(int x)&#123; if(t[x].mark==0) return ; int l=t[x].ls,r=t[x].rs,ma=t[x].mark; t[l].mark+=ma; t[l].sum+=ma*(t[l].r-t[l].l+1); t[r].mark+=ma; t[r].sum+=ma*(t[r].r-t[r].l+1); t[x].mark=0;&#125;void change(int x,int l,int r,int k)&#123; if(l&lt;=t[x].l&amp;&amp;t[x].r&lt;=r) &#123; t[x].mark+=k; t[x].sum+=k*(t[x].r-t[x].l+1); return ; &#125; push_(x); int mid=(t[x].l+t[x].r)/2; if(l&lt;=mid) change(t[x].ls,l,r,k); if(mid&lt;r) change(t[x].rs,l,r,k); t[x].sum=t[t[x].ls].sum+t[t[x].rs].sum;&#125;long long query(int x,int l,int r)&#123; if(l&lt;=t[x].l&amp;&amp;t[x].r&lt;=r) &#123; return t[x].sum; &#125; push_(x); long long ans=0; int mid=(t[x].l+t[x].r)/2; if(l&lt;=mid) ans+=query(t[x].ls,l,r); if(mid&lt;r) ans+=query(t[x].rs,l,r); return ans;&#125;int main()&#123;// freopen(\"tree.in\",\"r\",stdin); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;a[i]); build(1,1,n); int x,y,k; while(m--) &#123; scanf(\"%d\",&amp;q); if(q==1) &#123; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;k); change(1,x,y,k); &#125; else &#123; scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%lld\\n\",query(1,x,y)); &#125; &#125; return 0;&#125;","link":"","categories":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/categories/线段树/"},{"name":"二分","slug":"线段树/二分","permalink":"http://yoursite.com/categories/线段树/二分/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/二分/"},{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"易错点总结","date":"2016-10-16T10:45:42.000Z","path":"2016/10/16/易错点总结/","text":"前言其实就是我犯过的错误的总结。。。 总结1.空间限制计算空间的办法：$1024*1024*空间限制/4$ 2.文件输入输出一定不要忘写，一定不要写错位置，一定不要写错 3.变量定义定义的变量不要连自己都不认识。。。 先写这么多吧。。。","link":"","categories":[{"name":"noip","slug":"noip","permalink":"http://yoursite.com/categories/noip/"}],"tags":[{"name":"noip","slug":"noip","permalink":"http://yoursite.com/tags/noip/"}]},{"title":"SPFA","date":"2016-10-16T08:00:01.000Z","path":"2016/10/16/SPFA/","text":"前言恕我直言，在负边权面前，Dijkstra就是ZZ… 1.算法思想用一个dis[]数组储存出发点到该点的最短距离，用一个FIFO队列来记录待优化的结点，每次将队首结点取出，并用该结点的dis来更新与其直接连通的结点的dis值，如果一个点的dis值被修改了而且该点不在队列中，则将其放在队尾；不断重复该过程直到队列为空。此时，dis[]数组里储存的便是每个点到出发点的最短距离。 2.SPFA模板题【题目链接】洛谷【3371】【题目描述】如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。【输入格式】第一行包含三个整数N、M、S，分别表示点的个数、有向边的个数、出发点的编号。接下来M行每行包含三个整数Fi、Gi、Wi，分别表示第i条有向边的出发点、目标点和长度。【输出格式】一行，包含N个用空格分隔的整数，其中第i个整数表示从点S出发到点i的最短路径长度（若S=i则最短路径长度为0，若从点S无法到达点i，则最短路径长度为2147483647）【输入样例】 4 6 11 2 22 3 22 4 11 3 53 4 31 4 4 【输出样例】 0 2 4 3 【程序】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#define MAX 2147483647#define MIN 0#define M 500500using namespace std;int n,m,s;struct E&#123; int to,next,w;&#125;e[M];int tope,head[M];inline void ae(int x,int y,int z)&#123; tope++;e[tope].to=y;e[tope].next=head[x];head[x]=tope;e[tope].w=z;&#125;queue&lt;int&gt;q;int dis[M];bool in[M];inline void spfa(int x)&#123; int topp; for(int i=1;i&lt;=n;++i) &#123; dis[i]=MAX; &#125; q.push(x);dis[x]=0;in[x]=1; do &#123; topp=q.front(); q.pop(); in[topp]=0; for(int i=head[topp],p=e[i].to;i;i=e[i].next,p=e[i].to) &#123; if(dis[topp]+e[i].w&lt;dis[p]) &#123; dis[p]=dis[topp]+e[i].w; if(!in[p]) &#123; q.push(p); in[p]=1; &#125; &#125; &#125; &#125;while(!q.empty());&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s); int ta,tb,tc; for(int i=1;i&lt;=m;++i) &#123; scanf(\"%d%d%d\",&amp;ta,&amp;tb,&amp;tc); ae(ta,tb,tc); &#125; spfa(s); for(int i=1;i&lt;=n;++i) &#123; printf(\"%d \",dis[i]); &#125; return 0;&#125; 3.最短路计数【题目链接】洛谷【1144】【题目描述】给出一个N个顶点M条边的无向无权图，顶点编号为1～N。问从顶点1开始，到其他每个点的最短路有几条。【输入格式】输入第一行包含2个正整数N，M，为图的顶点数与边数。接下来M行，每行两个正整数x, y，表示有一条顶点x连向顶点y的边，请注意可能有自环与重边。【输出格式】输出包括N行，每行一个非负整数，第i行输出从顶点1到顶点i有多少条不同的最短路，由于答案有可能会很大，你只需要输出mod 100003后的结果即可。如果无法到达顶点i则输出0。【输入样例】 5 71 21 32 43 42 34 54 5 【输出样例】 11124 【程序】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#define MAX 2147483647#define MIN 0#define M 500500#define MOD 100003using namespace std;int n,m,s;struct E&#123; int to,next,w;&#125;e[M];int tope,head[M];inline void ae(int x,int y,int z)&#123; tope++;e[tope].to=y;e[tope].next=head[x];head[x]=tope;e[tope].w=z;&#125;queue&lt;int&gt;q;int dis[M],cnt[M];bool in[M];inline void spfa(int x)&#123; int topp; for(int i=1;i&lt;=n;++i) &#123; dis[i]=MAX; &#125; cnt[x]=1; q.push(x);dis[x]=0;in[x]=1; do &#123; topp=q.front(); q.pop(); in[topp]=0; for(int i=head[topp],p=e[i].to;i;i=e[i].next,p=e[i].to) &#123; if(dis[topp]+e[i].w&lt;dis[p]) &#123; dis[p]=dis[topp]+e[i].w; cnt[p]=cnt[topp]%MOD; if(!in[p]) &#123; q.push(p); in[p]=1; &#125; &#125; else &#123; if(dis[topp]+e[i].w==dis[p]) cnt[p]=(cnt[p]+cnt[topp])%MOD; &#125; &#125; &#125;while(!q.empty());&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); int ta,tb; for(int i=1;i&lt;=m;++i) &#123; scanf(\"%d%d\",&amp;ta,&amp;tb); ae(ta,tb,1); ae(tb,ta,1); &#125; spfa(1); for(int i=1;i&lt;=n;++i) &#123; if(dis[i]==MAX) printf(\"0\\n\"); else printf(\"%d\\n\",cnt[i]); &#125; return 0;&#125;","link":"","categories":[{"name":"SPFA","slug":"SPFA","permalink":"http://yoursite.com/categories/SPFA/"},{"name":"贪心","slug":"SPFA/贪心","permalink":"http://yoursite.com/categories/SPFA/贪心/"},{"name":"最短路","slug":"SPFA/贪心/最短路","permalink":"http://yoursite.com/categories/SPFA/贪心/最短路/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"},{"name":"SPFA","slug":"SPFA","permalink":"http://yoursite.com/tags/SPFA/"}]},{"title":"Dijkstra","date":"2016-10-16T08:00:01.000Z","path":"2016/10/16/Dijkstra/","text":"前言","link":"","categories":[{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://yoursite.com/categories/Dijkstra/"},{"name":"最短路","slug":"Dijkstra/最短路","permalink":"http://yoursite.com/categories/Dijkstra/最短路/"},{"name":"贪心","slug":"Dijkstra/最短路/贪心","permalink":"http://yoursite.com/categories/Dijkstra/最短路/贪心/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://yoursite.com/tags/Dijkstra/"},{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"}]},{"title":"Tarjan（强连通分量）","date":"2016-10-13T13:16:53.000Z","path":"2016/10/13/Tarjan/","text":"前言如何判环？用Tarjan啊！多好用啊！（虽然不会写啊）（要不然写这篇博客干啥啊） 1.思想参考第一道例题程序里的注释 2.Tarjan例题之信息传递（noip2015）【题目链接】洛谷【2661】【题目描述】有n个同学（编号为1到n）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为i的同学的信息传递对象是编号为Ti同学。游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？【输入格式】输入共2行。第1行包含1个正整数n表示n个人。第2行包含n个用空格隔开的正整数T1,T2,……,Tn其中第i个整数Ti示编号为i的同学的信息传递对象是编号为Ti的同学，Ti≤n且Ti≠i数据保证游戏一定会结束。【输出格式】输出共 1 行，包含 1 个整数，表示游戏一共可以进行多少轮。【输入样例】 52 4 2 3 1 【输出样例】 3 【题解】裸Tarjan。。。能传递回去就证明有环，能进行的次数就是最小环里的元素个数。【程序】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define M 500500using namespace std;int n,tmp;struct E&#123; int to,next,w;&#125;e[M];int tope,head[M];int dfn[M],low[M],isinstk[M],stk[M],stktop,dfstop,sov[M],totsov;inline void ae(int x,int y,int z)&#123; tope++;e[tope].to=y;e[tope].next=head[x];head[x]=tope;e[tope].w=z;&#125;void tarjan(int x)&#123; dfn[x]=low[x]=++dfstop; //将dfn和low值更新为dfs序 isinstk[x]=1; //入栈 stk[++stktop]=x; //入栈 for(int i=head[x],y=e[i].to;i;i=e[i].next,y=e[i].to) //链式前向星遍历 &#123; if(dfn[y]==0) //如果儿子节点的dfn值为0，跑它的tarjan，并更新它的low值 &#123; tarjan(y); low[x]=min(low[x],low[y]); //用low更新low，不要问为什么，记住就行 &#125; else if(isinstk[y]) //如果指向点在栈里，说明找到了一个强连通分量 low[x]=min(low[x],dfn[y]); //用dfn更新low，不要问为什么，记住就行 &#125; if(dfn[x]==low[x]) //dfn等于low就说明跑回来了，开始退栈 &#123; totsov++; int i; do &#123; i=stk[stktop--]; sov[totsov]++; isinstk[i]=0; &#125;while(i!=x); //如果用for或者while，起点不会退栈 &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%d\",&amp;tmp); ae(i,tmp,1); &#125; for(int i=1;i&lt;=n;++i) &#123; if(!dfn[i]) tarjan(i); &#125; sort(sov+1,sov+totsov+1); for(int i=1;i&lt;=totsov;++i) &#123; if(sov[i]&gt;1) &#123; printf(\"%d\",sov[i]); break; &#125; &#125; return 0;&#125; 3.Tarjan例题之上白泽慧音【题目链接】洛谷【1726】【题目描述】在幻想乡，上白泽慧音是以知识渊博闻名的老师。春雪异变导致人间之里的很多道路都被大雪堵塞，使有的学生不能顺利地到达慧音所在的村庄。因此慧音决定换一个能够聚集最多人数的村庄作为新的教学地点。人间之里由N个村庄（编号为1..N）和M条道路组成，道路分为两种一种为单向通行的，一种为双向通行的，分别用1和2来标记。如果存在由村庄A到达村庄B的通路，那么我们认为可以从村庄A到达村庄B，记为(A,B)。当(A,B)和(B,A)同时满足时，我们认为A,B是绝对连通的，记为。绝对连通区域是指一个村庄的集合，在这个集合中任意两个村庄X,Y都满足。现在你的任务是，找出最大的绝对连通区域，并将这个绝对连通区域的村庄按编号依次输出。若存在两个最大的，输出字典序最小的，比如当存在1,3,4和2,5,6这两个最大连通区域时，输出的是1,3,4。【输入格式】第1行：两个正整数N,M第2到M+1行：每行三个正整数a,b,t, t = 1表示存在从村庄a到b的单向道路，t = 2表示村庄a,b之间存在双向通行的道路。保证每条道路只出现一次。【输出格式】第1行： 1个整数，表示最大的绝对连通区域包含的村庄个数。第2行：若干个整数，依次输出最大的绝对连通区域所包含的村庄编号。【输入样例】 5 51 2 11 3 22 4 25 1 23 5 1 【输出样例】 31 3 5 【题解】在图中找出一个最大环，输出它的大小，并按字典序输出其中的元素。【程序】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define M 500500using namespace std;int n,m; struct E&#123; int to,next;&#125;e[M];int tope,head[M];int dfn[M],low[M],dfstop,stk[M],stktop,isinstk[M],sov[M],sovtot,maxsov[M];inline void ae(int x,int y)&#123; tope++;e[tope].to=y;e[tope].next=head[x];head[x]=tope;&#125;inline void tarjan(int x)&#123; dfn[x]=low[x]=++dfstop; isinstk[x]=1;stk[++stktop]=x; for(int i=head[x],y=e[i].to;i;i=e[i].next,y=e[i].to) &#123; if(!dfn[y]) &#123; tarjan(y); low[x]=min(low[x],low[y]); &#125; else if(isinstk[y]) low[x]=min(low[x],dfn[y]); &#125; if(dfn[x]==low[x]) &#123; sovtot++; int i=-1; do &#123; i=stk[stktop--]; sov[sovtot]++; maxsov[i]=sovtot; isinstk[i]=0; &#125;while(i!=x); &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); int ta,tb,tc; for(int i=1;i&lt;=m;++i) &#123; scanf(\"%d%d%d\",&amp;ta,&amp;tb,&amp;tc); ae(ta,tb); if(tc==2) &#123; ae(tb,ta); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; if(!dfn[i]) tarjan(i); &#125; int maxx=0,mpos=0; for(int i=1;i&lt;=sovtot;++i) &#123; if(sov[i]&gt;maxx) maxx=sov[i],mpos=i; &#125; printf(\"%d\\n\",maxx); for(int i=1;i&lt;=n;++i) &#123; if(maxsov[i]==mpos) printf(\"%d \",i); &#125; return 0;&#125;","link":"","categories":[{"name":"Tarjan","slug":"Tarjan","permalink":"http://yoursite.com/categories/Tarjan/"}],"tags":[{"name":"Tarjan","slug":"Tarjan","permalink":"http://yoursite.com/tags/Tarjan/"}]},{"title":"对拍","date":"2016-10-11T11:04:22.000Z","path":"2016/10/11/对拍/","text":"前言如何不用评测软件就能判断自己的程序写的对不对呢？答：用对拍啊！ 对拍模（mú）板1234567echo off:loop(造数据)/wait(暴力)/wait(测试程序)/waitfc (暴力).out (测试程序).out||pausegoto loop 最后文件名要改成***.bat，里面的括号及里面的东西改成程序名。 随机生成数据12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; freopen(\"data.in\",\"w\",stdout); srand(GetTickCount()); //确保数据随机，这只是很多写法里的一种 /* * 这里开始用一些奇奇怪怪的方法生成符合题目条件的数据 * 随机的东西用=rand()赋值 * 为了不超过数据范围，生成的数据要%一下 * 最后别忘了输出数据 */ return 0;&#125; 当然，对拍的时候程序会自行生成新的数据，所以不用担心一组数据不够用。 Tips1.暴力要是写错了，对拍也救不了你；2.所有相关的文件要放在同一目录下；3.对拍会停在第一组不匹配的数据那里，而且，你没法查看数据。。。只有结果。","link":"","categories":[{"name":"对拍","slug":"对拍","permalink":"http://yoursite.com/categories/对拍/"}],"tags":[{"name":"对拍","slug":"对拍","permalink":"http://yoursite.com/tags/对拍/"}]},{"title":"对组（pair）","date":"2016-10-03T08:26:43.000Z","path":"2016/10/03/对组/","text":"前言不想写结构体了？这里有个好东西，可以一句话代替两个元素的结构体，还不来试试？ 1.简介头文件#include&lt;utility&gt; STL的头文件中描述了一个非常简单的模板类pair，用来表示一个二元组或元素对，并提供了大小比较的比较运算符模板函数。 pair模板类需要两个参数：首元素的数据类型和尾元素的数据类型。pair模板类对象有两个成员：first和second，分别表示首元素和尾元素。 在头文件中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;=、&gt;=、==、!=，其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑。当然，也可以通过重载这几个运算符来重新指定自己的比较逻辑。 pair的内建函数make_pair(a,b)直接返回一个pair类，嵌套在其他数据结构（堆，队列，向量，map…）时使用比较方便。","link":"","categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"关联式容器（map）","date":"2016-10-03T07:10:46.000Z","path":"2016/10/03/关联式容器（map）/","text":"前言关联式容器就像一个下标是任何类型的数组，比如，一个int类型的数组，下标用string类型的，$int_{string}$官方解释是一个有序的映射表。。。 1.定义头文件#include&lt;map&gt; map&lt;类型1，类型2&gt;变量名; 123map&lt;string,int&gt;ma; //定义ma为一个从string到int的一个映射ma[\"abc\"]=2; //将字符串“abc”映射到整数“2”上cout&lt;&lt;ma[\"abc\"]&lt;&lt;endl; //输出“abc”的映射“2” 2.操作 操作 用途 operator[] 访问map中的元素，若该元素不存在，将创建一个新元素映射到类型2的初始值上 ma.begin() 返回map中第一个元素的指针 ma.end() 返回map中最后一个元素的后一个元素的指针 ma.size() 返回map中元素的个数 ma.count(element) 若元素element存在于map中返回1，否则返回0 ma.clear() 初始化map 示例：1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;map&lt;string,int&gt;ma; //定义一个下标为int类型的string类型的“数组” int main()&#123; ma[\"apple\"]=1; //“apple”的下标为1 ma[\"banana\"]=2; //“banana”的下标为2 ma[\"lemon\"]=3; //“lemon”的下标为3 cout&lt;&lt;ma.size()&lt;&lt;endl; //输出ma的元素个数 cout&lt;&lt;ma[\"apple\"]&lt;&lt;endl; //输出“apple”的下标 if(ma.count(\"pear\")) cout&lt;&lt;\"pear\"&lt;&lt;endl; //如果ma里有“pear”，则输出“pear” ，否则输出“no pear” else cout&lt;&lt;\"no pear\"&lt;&lt;endl; return 0;&#125; 运行结果：","link":"","categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"单调队列","date":"2016-10-02T01:39:18.000Z","path":"2016/10/02/单调队列/","text":"前言其实单调队列不是真正意义上的队列，它只是一个存在于你脑海里的一个虚拟的队列，虚拟地进行队列的操作。。。（好玄学~~） 0.单调队列思想单调队列，正如其名，是一个单调的队列，单调递增或者单调递减，所以队首永远是最小值或最大值，这就是单调队列的用处——求一段区间里的最大值或最小值。 1.单调队列操作通常我们用一个a[]数组存原数组，用一个q[]数组表示单调队列，这个q[]数组存的是队列里元素在原数组里的位置标号（下标）。单调队列与别的队列的原理不太一样，它是在队尾插入元素，在两头删除元素。 下面以一个单调递增队列为例： 入队操作将要放入队尾的元素e与队尾元素t进行比较，如果e&lt;t,则将t踢出队列，继续拿e与队尾元素比较，直到找到一个元素k&lt;e，把e放在k的后面，至于那些被踢掉的元素。。。就不要了。 出队操作因为单调队列是要求区间的最小值，所以前面的元素总会有没用的时候，这个时候就要把那些被顶出区间的元素踢掉。 2.单调队列裸题讲了这么多感觉还是很玄学，那就拿例题来解释吧~~【题目链接】洛谷【1440】【题目描述】一个含有n项的数列(n&lt;=2000000)，求出每一项前的m个数到它这个区间内的最小值。若前面的数不足m项则从第1个数开始，若前面没有数则输出0。【输入格式】第一行两个数n，m。第二行，n个正整数，为所给定的数列。【输出格式】n行，第i行的一个数ai，为所求序列中第i个数前m个数的最小值。【输入样例】 6 27 8 1 4 3 2 【输出样例】 077113 【说明】数据范围：m≤n≤2000000 【题解】多么裸的单调队列~~弄一个单调递增的单调队列，每次输出队首元素a[q[head]]。有一点要注意的：“所求序列中第i个数前m个数的最小值”.（第一次被坑了） 【程序】1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;iostream&gt;#define M 2000100using namespace std;int n,m;int a[M]; //原数组 int q[M]; //单调队列 int head=1,tail=1; //head————头指针，tail————尾指针 inline void push(int x)&#123; while(head&lt;=tail&amp;&amp;a[x]&lt;=a[q[tail]]) //如果a[x]小于队尾元素，则将队尾元素踢掉，即尾指针前移 tail--; q[++tail]=x; //踢完之后把a[x]放在队尾 &#125;inline void pop(int x)&#123; if(q[head]&lt;x-m+1) //如果队首元素不在区间里，踢掉它，即头指针后移 head++;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]); printf(\"0\\n\");q[1]=1; //第一次输出0，题目要求。。。 for(int i=2;i&lt;=n;++i) &#123; printf(\"%d\\n\",a[q[head]]); push(i); //入队 pop(i); //出队 &#125; return 0;&#125;","link":"","categories":[{"name":"队列","slug":"队列","permalink":"http://yoursite.com/categories/队列/"},{"name":"单调队列","slug":"队列/单调队列","permalink":"http://yoursite.com/categories/队列/单调队列/"}],"tags":[{"name":"队列","slug":"队列","permalink":"http://yoursite.com/tags/队列/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"}]},{"title":"FIFO队列与优先队列","date":"2016-09-22T13:19:59.000Z","path":"2016/09/22/FIFO队列与优先队列/","text":"前言队列是个好东西，可以手写，也可以用C++自带的queue头文件来写。 定义队列#include&lt;queue&gt; FIFO队列 queue &lt;类型&gt; 变量名 123queue &lt;int&gt; que //定义一个int类型的名为que的FIFO队列queue &lt;char&gt; a //定义一个char类型的名为a的FIFO队列queue &lt;data&gt; c //定义一个data（自定义数据类型）类型的名为c的FIFO队列 优先队列 priority_queue &lt;类型&gt; 变量名; 12priority_queue &lt;int&gt; heap; //定义一个int类型的名为heap的优先队列priority_queue &lt;double&gt; k; //定义一个double类型的名为k的优先队列 这两种定义方式都是大根堆，转为小根堆有两种方法：一是每个数据都乘以-1；二是自定义数据类型：1234567struct data&#123; int x; bool operator &lt; (const data &amp; a)const &#123; return a.x&lt;x; &#125;&#125;;priority_queue &lt;data&gt; q; 队列操作此处以一个名为q的队列为例： 操作 用途 q.empty() 若队列为空，则返回true，否则返回false q.size() 返回队列中元素的个数 q.pop() 删除队首元素，但不返回其值 q.front() 返回队首元素的值，但不删除该元素（仅适用于FIFO队列） q.back() 返回队尾元素的值，但不删除该元素（仅适用于FIFO队列） q.top() 返回具有最高优先级的元素的值（默认最大值），但不删除该元素（仅适用于优先队列） q.push() 对queue，在队尾压入一个新元素对于priority_queue，在基于优先级的适当位置插入新元素 简单例题洛谷【1090】（合并果子）123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int n,x,ans=0,tmp;priority_queue &lt;int&gt; q;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%d\",&amp;x); q.push(-x); &#125; for(int i=1;i&lt;n;++i) &#123; tmp=q.top(); ans-=q.top(); q.pop(); tmp+=q.top(); ans-=q.top(); q.pop(); q.push(tmp); &#125; printf(\"%d\",ans); return 0;&#125;","link":"","categories":[{"name":"队列","slug":"队列","permalink":"http://yoursite.com/categories/队列/"},{"name":"STL","slug":"队列/STL","permalink":"http://yoursite.com/categories/队列/STL/"}],"tags":[{"name":"队列","slug":"队列","permalink":"http://yoursite.com/tags/队列/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"贪心算法——从入门到放弃","date":"2016-09-21T11:34:34.000Z","path":"2016/09/21/贪心算法/","text":"前言有人说贪心算法是最简单的算法，原因很简单：你我其实都很贪，根本不用学就知道怎么贪。有人说贪心算法是最复杂的算法，原因也很简单：这世上会贪的人太多了，哪轮到你我的份？ 0.贪心入门顾名思义，贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，希望贪心算法得到的最终结果也是整体最优的。虽然贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解。如单源最短路径问题（SPFA，Dijkstra），最小生成树问题等。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。 1.贪心经典例题之均分纸牌【题目链接】洛谷【1031】【题目描述】有 N 堆纸牌，编号分别为 1，2，…, N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。移牌规则为：在编号为 1 堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 N 的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。例如 N=4，4 堆纸牌数分别为：① 9 ② 8 ③ 17 ④ 6移动3次可达到目的：从 ③ 取 4 张牌放到 ④ （9 8 13 10） -&gt; 从 ③ 取 3 张牌放到 ②（9 11 10 10）-&gt; 从 ② 取 1 张牌放到①（10 10 10 10）。【输入格式】N（N 堆纸牌，1 &lt;= N &lt;= 100）A1 A2 … An （N 堆纸牌，每堆纸牌初始数，l&lt;= Ai &lt;=10000）【输出格式】所有堆均达到相等时的最少移动次数。【输入样例】 49 8 17 6 【输出样例】 3 【题解】从左到右依次扫描，大于平均数的就把多的部分给右边那堆，小于平均数的就从右边那堆拿过来，由左至右逐渐等于平均数。【程序】123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,aid,a[105],tot=0,sum=0,you;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%d\",&amp;a[i]); tot+=a[i]; &#125; aid=tot/n; ////// for(int i=1;i&lt;=n-1;++i) &#123; if(a[i]-aid&lt;0) &#123; a[i+1]+=a[i]-aid; sum++; &#125; if(a[i]-aid&gt;0) &#123; a[i+1]+=a[i]-aid; sum++; &#125; &#125; printf(\"%d\",sum); return 0;&#125; 2.贪心经典例题之导弹拦截（第二问）【题目链接】洛谷【1020】【题目描述】某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。【输入格式】一行，若干个正整数。【输出格式】2行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。【输入样例】 389 207 155 300 299 170 158 65 【输出样例】 62 【题解】贪心策略：用一个tmp[]数组储存每套系统拦截的最低的导弹高度，每次新来的导弹与每套系统进行比较，如果小于其中一套的最低高度，则用该套系统拦截；如果都不能拦截，则新建一套系统。【程序】1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#define M 500500using namespace std;int t=1,stot=1,tot=0;int a[M],tmp[M];int f[M];bool b;int main()&#123; while(scanf(\"%d\",&amp;a[t])!=EOF) &#123; b=1; for(int i=1;i&lt;=stot;++i) &#123; if(a[t]&lt;=tmp[i]) &#123; b=0; tmp[i]=a[t]; break; &#125; &#125; if(b) tmp[stot++]=a[t]; t++; &#125; t--;stot--; printf(\"%d\",stot); return 0;&#125; 【说明】这里只是第二问的解法和程序，第一问的相关内容已删去。 3.贪心水题之合并果子【题目链接】洛谷【1090】【题目描述】在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。【输入格式】包括两行，第一行是一个整数n(1&lt;＝n&lt;=10000)，表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai(1&lt;＝ai&lt;=20000)是第i种果子的数目。【输出格式】包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于$2^31$。【输入样例】 31 2 9 【输出样例】 15 【题解】贪心策略：每次将最小的两堆果子合并。。。【程序】123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int n,x,ans=0,tmp;priority_queue &lt;int&gt; q;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%d\",&amp;x); q.push(-x); &#125; for(int i=1;i&lt;n;++i) &#123; tmp=q.top(); ans-=q.top(); q.pop(); tmp+=q.top(); ans-=q.top(); q.pop(); q.push(tmp); &#125; printf(\"%d\",ans); return 0;&#125; 【说明】这里用到了优先队列，书上有教程。。。 4.乱入例题之独木桥（个人觉得有点贪心的感觉）【题目链接】洛谷【1007】【题目背景】战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳一个人通过。假如有两个人相向而行在桥上相遇，那么他们两个人将无妨绕过对方，只能有一个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。【题目描述】突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为L，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为1，但一个士兵某一时刻来到了坐标为0或L+1的位置，他就离开了独木桥。每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。【输入格式】第一行：一个整数L，表示独木桥的长度。桥上的坐标为1…L；第二行：一个整数N，表示初始时留在桥上的士兵数目；第三行：有N个整数，分别表示每个士兵的初始坐标。【输出格式】只有一行，输出两个整数，分别表示部队撤离独木桥的最小时间和最大时间。两个整数由一个空格符分开。【输入样例】 421 3 【输出样例】 2 4 【说明】初始时，没有两个士兵同在一个坐标。数据范围N&lt;=L&lt;=1000。【题解】请仔细想想再看题解 当两个士兵相遇时，两人均掉头，但是也可以理解为两人换了个位置继续前进，所以最短时间就是离岸最近的士兵花的时间，最长时间就是离岸最远的士兵花的时间。【程序】12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int n,l;int x; int maxx=0,minn=0;int main()&#123; scanf(\"%d%d\",&amp;l,&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;x); maxx+=max(0,max(x,l-x+1)-maxx); minn+=max(0,min(x,l-x+1)-minn); &#125; printf(\"%d %d\",minn,maxx); return 0;&#125; -1.贪心放弃如果你实在学不会贪心，放弃吧少年。。。-the end-撒花*\\ (￣▽￣)/~","link":"","categories":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/categories/贪心/"},{"name":"经典算法","slug":"贪心/经典算法","permalink":"http://yoursite.com/categories/贪心/经典算法/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"经典算法","slug":"经典算法","permalink":"http://yoursite.com/tags/经典算法/"}]},{"title":"分治算法——从入门到放弃","date":"2016-09-20T13:11:46.000Z","path":"2016/09/20/分治算法/","text":"前言 5aSn5a626YO96KeJ5b6X5oiR5LqM5YiG6K6y5b6X5LiN5aW977yM5omA5Lul5omT566X5YaZ5Liq5Y2a5a6i5p2l5byl6KGl44CC44CC44C Tips:base64解码 0.二分入门二分思想就是把一个大问题分解成许多个解法相同的小问题来解决，这样就可以把一个O(n)复杂度的程序优化成O(log n)的复杂度。 1.二分经典例题之循环赛日程表【题目描述】设有n=$2^k$个选手参加比赛，要求设计一个满足一下要求的比赛日程表:（1）每个选手必须与其他的n-1个选手个比赛一次；（2）每个选手每天只能赛一次 。【输入格式】只有一个正整数k【输出格式】请输出一个n行，每行有n个正整数的循环赛日程表。相邻的两个正整数用一个空格隔开。其中，第i行（0&lt;i&lt;n+1）表示第i队的参赛日程，第1个正整数为i，表示参赛队的队号，后面的(n-1)个正整数表示该队在参赛日程中，依次较量的队号。【样例输入】 1 【样例输出】 1 22 1 【说明】0&lt;k&lt;9（k属于正整数）【题解】假设n位选手被顺序编号为1,2,3,…,n，比赛的日程表是一个n行n-1列的表格，i行j列的表格内容是第i号选手在第j天的比赛对手。根据分而治之的原则，可从其中一半选手($2^(n-1)$位)的比赛日程，导出全体n位选手的日程，最终细分到只有两位选手的比赛日程出发。可假设只有8位选手参赛，若1至4号选手之间的比赛日程填在日程表的左上角(4行3列)，5至8号选手之间的比赛日程填在日程表的左下角(4行3列)；那么左下角的内容可由左上角的对应项加上数字4得到。至此，剩余的右上角(4行4列)是为编号小的1至4号选手与编号大的5至8号选手之间的比赛日程安排。例如，在第4天，让1至4号选手分别与5至8号选手比赛，以后各天，依次由前一天的日程安排，让5至8号选手“循环轮转”即可。最后，比赛日程表的右下角的比赛日程表可由，右上角的对应项减去数字4得到。 k=3时的图例： 选手 1天 2天 3天 4天 5天 6天 7天 1号 2 3 4 5 6 7 8 2号 1 4 3 6 7 8 7 3号 4 1 2 7 8 5 6 4号 3 2 1 8 5 6 5 左上角 右上角 5号 6 7 8 1 4 3 2 6号 5 8 7 2 1 4 3 7号 8 5 6 3 2 1 4 8号 7 6 5 4 3 2 1 左下角 右下角 【程序】 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int k;int a[100][100];int n,temp;void gametable(int x)&#123; n=2;//k=0两个参赛选手日程可以直接求得 a[1][1]=1;a[1][2]=2; a[2][1]=2;a[2][2]=1; for(int t=1;t&lt;x;t++)//迭代处理，依次处理2^n....2^k个选手的比赛日程 &#123; temp=n;n=n*2;//填左下角元素 for(int i=temp+1;i&lt;=n;i++) for(int j=1;j&lt;=temp;j++) a[i][j]=a[i-temp][j]+temp;//左下角和左上角元素的对应关系 for(int i=1;i&lt;=temp;i++)//将左下角元素抄到右上角 for(int j=temp+1;j&lt;=n;j++) a[i][j]=a[i+temp][(j+temp)%n]; for(int i=temp+1;i&lt;=n;i++)//将左上角元素抄到右下角 for(int j=temp+1;j&lt;=n;j++) a[i][j]=a[i-temp][j-temp]; &#125; //第i行第j列表示和第i个选手在第j天比赛的选手序号 for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf(\"%d \",a[i][j]); printf(\"\\n\"); &#125; &#125;int main()&#123; scanf(\"%d\",&amp;k); if(k!=0) gametable(k); return 0;&#125;//该程序取自网络，并非本人亲自所写 2.二分联赛例题之跳石头【题目链接】洛谷【P2678】跳石头【题目背景】一年一度的“跳石头”比赛又要开始了!【题目描述】这项比赛将在一条笔直的河道中进行,河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间,有 N 块岩石(不含起点和终 点的岩石)。在比赛过程中,选手们将从起点出发,每一步跳向相邻的岩石,直至到达 终点。 为了提高比赛难度,组委会计划移走一些岩石,使得选手们在比赛过程中的最短跳 跃距离尽可能长。由于预算限制,组委会至多从起点和终点之间移走 M 块岩石(不能 移走起点和终点的岩石)。【输入格式】输入文件名为 stone.in。输入文件第一行包含三个整数 L,N,M,分别表示起点到终点的距离,起点和终 点之间的岩石数,以及组委会至多移走的岩石数。接下来 N 行,每行一个整数,第 i 行的整数 Di(0 &lt; Di &lt; L)表示第 i 块岩石与 起点的距离。这些岩石按与起点距离从小到大的顺序给出,且不会有两个岩石出现在同 一个位置。【输出格式】输出文件名为 stone.out。 输出文件只包含一个整数,即最短跳跃距离的最大值。【输入样例】 25 5 2211141721 【输出样例】 4 【说明】输入输出样例 1 说明：将与起点距离为 2 和 14 的两个岩石移走后,最短的跳跃距离为 4(从与起点距离 17 的岩石跳到距离 21 的岩石,或者从距离 21 的岩石跳到终点)。 另：对于 20%的数据,0 ≤ M ≤ N ≤ 10。 对于50%的数据,0 ≤ M ≤ N ≤ 100。对于 100%的数据,0 ≤ M ≤ N ≤ 50,000,1 ≤ L ≤ 1,000,000,000。 【题解】二分答案+贪心所谓二分答案就是确定一个答案的范围，然后将这个范围进行二分，然后对mid进行判断，如果答案小于mid则二分mid的左半部分，反之二分mid的右半部分，最后左右端点重合（或者相差1），得到的就是答案。这道题二分答案的判断部分用到的就是贪心，关于贪心的问题可以参考其他博客。【程序】 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 50500using namespace std;int L,m,n,l,r,mid,ans,st;int a[N];int main()&#123; freopen(\"stone.in\",\"r\",stdin); freopen(\"stone.out\",\"w\",stdout); scanf(\"%d%d%d\",&amp;L,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]); a[++n]=L; l=0;r=L; //将首尾的石头放入数组 while(l&lt;=r) //这里用的是非递归的二分 &#123; mid=(l+r)/2; //////check ans=0;st=0; for(int i=1;i&lt;=n;++i) &#123; if(a[i]-st&lt;mid) ans++; //符合条件，移走石头 else st=a[i]; //不符合，从当前石头往后搜 &#125; if(ans&gt;m) //非递归二分格式 r=mid-1; else l=mid+1; &#125; printf(\"%d\",l-1); return 0;&#125; 3.二分经典例题之归并排序求逆序对归并排序归并排序_百度百科 UP主很良(wu)心(liang)地粘了个百科的链接。。。 归并排序求逆序对【题目链接】POJ【1804】【题目背景】Raymond Babbitt drives his brother Charlie mad. Recently Raymond counted 246 toothpicks spilled all over the floor in an instant just by glancing at them. And he can even count Poker cards. Charlie would love to be able to do cool things like that, too. He wants to beat his brother in a similar task.【题目描述】Here’s what Charlie thinks of. Imagine you get a sequence of N numbers. The goal is to move the numbers around so that at the end the sequence is ordered. The only operation allowed is to swap two adjacent numbers. Let us try an example:Start with: 2 8 0 3swap (2 8) 8 2 0 3swap (2 0) 8 0 2 3swap (2 3) 8 0 3 2swap (8 0) 0 8 3 2swap (8 3) 0 3 8 2swap (8 2) 0 3 2 8swap (3 2) 0 2 3 8swap (3 8) 0 2 8 3swap (8 3) 0 2 3 8 So the sequence (2 8 0 3) can be sorted with nine swaps of adjacent numbers. However, it is even possible to sort it with three such swaps:Start with: 2 8 0 3swap (8 0) 2 0 8 3swap (2 0) 0 2 8 3swap (8 3) 0 2 3 8 The question is: What is the minimum number of swaps of adjacent numbers to sort a given sequence?Since Charlie does not have Raymond’s mental capabilities, he decides to cheat. Here is where you come into play. He asks you to write a computer program for him that answers the question. Rest assured he will pay a very good prize for it.【大概翻译】给定一个序列,每次只允许交换相邻两个数,最少要交换多少次才能把它变成非递降序列.【输入格式】第一行输入情景数n.接下来n行，每一行第一个数表示序列长度为N（1≤N≤1000），其次是N个元素的序列（每个元素是一个整数，在[-1000000，1000000]）。在这一行的数字都是由单个空格分隔。【输出格式】对于每个情景，先输出”Scenario #i:”（i从1开始递增），然后输出最小的交换次数。【输入样例】 44 2 8 0 310 0 1 2 3 4 5 6 7 8 96 -42 23 6 28 -100 655375 0 0 0 0 0 【输出样例】 Scenario #1:3Scenario #2:0Scenario #3:5Scenario #4:0 【题解】 归并排序是将数列a[l,r]分成两半a[l,mid]和a[mid+1,r]分别进行归并排序，然后再将这两半合并起来。在合并的过程中（设l&lt;=i&lt;=mid，mid+1&lt;=j&lt;=r），当a[i]&lt;=a[j]时，并不产生逆序数；当a[i]&gt;a[j]时，在前半部分中比a[i]大的数都比a[j]大，将a[j]放在a[i]前面的话，逆序数要加上mid+1-i。因此，可以在归并排序中的合并过程中计算逆序数. 【程序】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;iostream&gt;#define M 500500using namespace std;int n,T;int ans;int a[M],tmp[M];void Merge(int l,int m,int r) //统计逆序对&#123; int i=l; int j=m+1; int k=l; while(i&lt;=m&amp;&amp;j&lt;=r) &#123; if(a[i]&gt;a[j]) &#123; tmp[k++]=a[j++]; ans+=m-i+1; &#125; else &#123; tmp[k++]=a[i++]; &#125; &#125; while(i&lt;=m) tmp[k++]=a[i++]; while(j&lt;=r) tmp[k++]=a[j++]; for(int i=l;i&lt;=r;i++) a[i]=tmp[i];&#125;void Merge_sort(int l,int r) //归并排序&#123; int mid=(l+r)&gt;&gt;1; if(l&lt;r) &#123; Merge_sort(l,mid); Merge_sort(mid+1,r); Merge(l,mid,r); &#125;&#125;int main()&#123; scanf(\"%d\",&amp;T); for(int t=1;t&lt;=T;++t) &#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]); Merge_sort(1,n); printf(\"Scenario #%d:\\n%d\\n\\n\",t,ans); ans=0; &#125; return 0;&#125; -1.二分放弃如果你并不能学会二分。。。放弃好了。。。-the end-撒花*\\ (￣▽￣)/~","link":"","categories":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/categories/二分/"},{"name":"二分查找","slug":"二分/二分查找","permalink":"http://yoursite.com/categories/二分/二分查找/"},{"name":"二分答案","slug":"二分/二分查找/二分答案","permalink":"http://yoursite.com/categories/二分/二分查找/二分答案/"},{"name":"归并排序","slug":"二分/二分查找/二分答案/归并排序","permalink":"http://yoursite.com/categories/二分/二分查找/二分答案/归并排序/"},{"name":"经典算法","slug":"二分/二分查找/二分答案/归并排序/经典算法","permalink":"http://yoursite.com/categories/二分/二分查找/二分答案/归并排序/经典算法/"}],"tags":[{"name":"经典算法","slug":"经典算法","permalink":"http://yoursite.com/tags/经典算法/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/二分/"},{"name":"二分答案","slug":"二分答案","permalink":"http://yoursite.com/tags/二分答案/"},{"name":"二分查找","slug":"二分查找","permalink":"http://yoursite.com/tags/二分查找/"},{"name":"归并排序","slug":"归并排序","permalink":"http://yoursite.com/tags/归并排序/"}]},{"title":"打表大神的对抗","date":"2016-09-20T11:56:09.000Z","path":"2016/09/20/打表大神的对抗/","text":"前言打表是一项极其重要的技能，仅次于暴力和骗分。。。 来自机房两位神犇的打表的研究 Franky（网上有许多转载Franky神犇文章而不注明出处的，请大家见到后积极点“踩”，有能力的可以进行举报，维护版权） V.S. Naivekun（Naive神犇（但是他自己不承认）用的Hexo，网上没法直接搜到，所以基本没人能偷走他的文章） *这两篇文章均为转载，已注明出处。。。","link":"","categories":[{"name":"打表","slug":"打表","permalink":"http://yoursite.com/categories/打表/"},{"name":"转载","slug":"打表/转载","permalink":"http://yoursite.com/categories/打表/转载/"}],"tags":[{"name":"打表","slug":"打表","permalink":"http://yoursite.com/tags/打表/"},{"name":"转载","slug":"转载","permalink":"http://yoursite.com/tags/转载/"}]},{"title":"霓虹语学习","date":"2016-09-14T16:00:00.000Z","path":"2016/09/15/霓虹语学习/","text":"前言私は中国人です 入门先背五十音图","link":"","categories":[{"name":"日本語","slug":"日本語","permalink":"http://yoursite.com/categories/日本語/"}],"tags":[{"name":"日本語","slug":"日本語","permalink":"http://yoursite.com/tags/日本語/"}]},{"title":"Hexo个人心得","date":"2016-09-09T16:00:00.000Z","path":"2016/09/10/Hexo个人心得/","text":"前言Hexo很好用的，向大家安利一下~~ 顺便记录一下Hexo的一些技巧~~ 首先感谢一下Fancy的兹磁，在Fancy的引（gu）导（huo）下我入坑了Hexo.","link":"","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"},{"name":"Hexo","slug":"博客/Hexo","permalink":"http://yoursite.com/categories/博客/Hexo/"},{"name":"施工中。。。","slug":"博客/Hexo/施工中。。。","permalink":"http://yoursite.com/categories/博客/Hexo/施工中。。。/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"施工中。。。","slug":"施工中。。。","permalink":"http://yoursite.com/tags/施工中。。。/"}]},{"title":"节操","date":"2016-09-08T11:09:12.000Z","path":"2016/09/08/节操/","text":"我是节操节操是我的外号这个博客里什么都没有不信自己看 123456789#include&lt;iostream&gt;using namesapce std;int main()&#123; printf(\"I'm Jiecao.\"); return 0;&#125; 啦啦啦~~~ 1OVERWATCH","link":"","categories":[{"name":"瞎搞","slug":"瞎搞","permalink":"http://yoursite.com/categories/瞎搞/"}],"tags":[{"name":"瞎搞","slug":"瞎搞","permalink":"http://yoursite.com/tags/瞎搞/"}]}]